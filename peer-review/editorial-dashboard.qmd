--- 
title: "pyOpenSci Editorial Dashboard"
format: 
  dashboard:
    scrolling: true 
execute:
  echo: false
--- 


```{python}
#| echo: false

# TODO: The next thing to add - now that we have a way to offboard is to list all editors that are running reviews and will be offboarded when the review is done. This would be people who are in the emeritus list that are also named on a review

import os
from pathlib import Path

import warnings
from datetime import datetime, timezone

import altair as alt
from itables import show
import pandas as pd
import pytz
import plotly.express as px
from plotly.subplots import make_subplots
from pyosmeta import ProcessIssues
from pyosmeta.github_api import GitHubAPI

# Suppress all warnings
warnings.filterwarnings("ignore")
# Make tables nicer
pd.set_option("display.max_colwidth", None)
current_date = datetime.today().date()
today = current_date.strftime("%d %B %Y") 
```


```{python}
def clean_and_order(df, DROP_COLS, order):
    """Drop columns and reorder DataFrame columns."""
    return df.drop(columns=DROP_COLS, errors="ignore")[ORDER]

def get_status_df(df, status):
    return df[df["active_status"] == status].reset_index(drop=True)

DROP_COLS = ["date_accepted", "labels", "editor", "status", "active_status"] 
ORDER = ["Name", "Description", "Days Open", "Date Opened","Last Comment", "Last User to Comment", "Issue", "Categories", "eic"]

label_map = {
    "pre-review": [
        "New Submission!", 
        "0/pre-review-checks"],
    "seeking editor": ["0/seeking-editor"],
    "seeking reviewers": ["2/seeking-reviewers"],
    "under-review": [
        "1/editor-assigned",
        "3/reviewers-assigned",
        "4/reviews-in-awaiting-changes",
        "5/awaiting-reviewer-response",
    ],
    "accepted-open": ["6/pyOS-approved", "9/joss-approved"],
}

def get_active_status(labels):
    """A function that returns an review status value based on a list of 
    label values available in the issue.
    """
    
    for status, label_list in label_map.items():
        if any(label in labels for label in label_list):
            return status
    return "unknown"
```


```{python}
#| echo: false

# Open submission review data
data_path = Path.cwd().parents[0] / "_data" / "review_submissions.csv"
reviews = pd.read_csv(data_path,
    parse_dates=["date_opened", "date_closed", "last_comment_date"],
)
reviews["date_opened"] = reviews["date_opened"]
reviews["last_comment_date"] = reviews["last_comment_date"]
reviews = reviews.rename(
    columns={
        "package_name": "Name",
        "date_opened": "Date Opened",
        "date_closed": "Date Closed",
        "issue_num": "Issue",
        "description": "Description",
        "categories": "Categories",
        "last_comment_date": "Last Comment",
        "last_comment_user": "Last User to Comment",
    }
)

open_reviews = reviews[reviews["Date Closed"].isna()]
open_reviews.drop(columns=["Date Closed","Unnamed: 0"], inplace=True)

editors = open_reviews["editor"].astype(str).str.split().str[0]
editors = editors[editors != "TBD"]

active_editor_counts = (
    editors.value_counts()
    .rename_axis("gh_username")
    .reset_index(name="count")
)

```


```{python}
# Open editor team data
# The total list is derived from the scripts/editors.py script which parses the (active) editorial team data. 
# The data opened in this section is collected using the scripts/get-editors.py workflow.

editor_path = Path.cwd().parents[0] / "_data" /  "editorial_team_domains.csv"
all_editors = pd.read_csv(editor_path)
all_editors = all_editors[["gh_username","first_name","Domain_areas","Description","technical_areas"]]

emeritus_editor_path = Path.cwd().parents[0] / "_data" /  "emeritus_editor_domains.csv"
emeritus_editors = pd.read_csv(emeritus_editor_path)

editor_activity = (
    all_editors.merge(active_editor_counts, on="gh_username", how="left")
               .fillna({"count": 0})
)
editor_activity["count"] = editor_activity["count"].astype(int)
editor_activity = editor_activity.sort_values(by="count", ascending=False).reset_index(drop=True)

# Get counts of available and busy editors
available_editors = editor_activity[editor_activity["count"] == 0]
busy_editors = editor_activity[editor_activity["count"] != 0]
num_available_editors = len(available_editors)

# Rename and cleanup
editor_activity = editor_activity.rename(columns={"count": "active review count"})
col = editor_activity.pop("active review count")
editor_activity.insert(1, "active review count", col)

# Next, compare editor activity to editors that want to offboard after that review
offboard_usernames = emeritus_editors["gh_username"]
active_editors = open_reviews["editor"].dropna()
active_editors = active_editors[active_editors != "TBD"]
active_editors = active_editors.astype(str).str.split(r"[ ,&]", n=1).str[0]

# TODO: note that blockingpy by data need to be updated - carter should be first here...

# TODO - filter reviews df by editors that are in the emeritus df (emeritus_editors)
offboard_usernames = emeritus_editors["gh_username"]

# This doesn't work - pick up here
# offboard_reviews = reviews[editor.isin(offboard_usernames)].copy()
# offboard_reviews

# Active editors are ones that are currently leading reviews. But some may intend to offboard after. Generate a list of reviews lead by those
offboarding_editor_reviews = open_reviews[open_reviews["editor"].isin(offboard_usernames)].copy()
```


## Row {height=auto}

```{python}
#| content: valuebox
#| title: "Total Editors"

dict(
  icon = "people-fill",
  color = "primary",
  value = len(all_editors)
)
```

```{python}
#| content: valuebox
#| title: "Busy Editors"
# fails if the value isn't an int
dict(
  icon = "box2-heart",
  color = "primary",
  value = len(busy_editors)
)
```

```{python}
#| content: valuebox
#| title: "Available Editors"
# fails if the value isn't an int
dict(
  icon = "person-hearts",
  color = "primary",
  value = len(available_editors)
)
```

## Row {height=5%}

```{python}
#| title: "pyOpenSci Current Active  Editorial Review Counts" 
show(editor_activity)
```

## Row {height=auto}

```{python}
#| title: "Editors Leading Reviews That Are or Have Offboarded After" 

# TODO: The table below is a good start but it should capture AMS lead by Nima as well. And the one that Chiara still has opened.  
print("Below are reviews that the peer review lead and Editor in Chief should watch. We may need to assign an additional editor the ensure these reviews moves forward.")

offboarding_editor_reviews = offboarding_editor_reviews.drop(columns=["date_accepted", "Categories"], errors="ignore")
offboarding_editor_reviews["Date Opened"] = pd.to_datetime(offboarding_editor_reviews["Date Opened"]).dt.strftime("%Y-%b-%d")

offboarding_editor_reviews

```

## Row {height=auto}

```{python}
#| title: "Busy editors running reviews "
show(busy_editors)
```

## Row {height=auto}
```{python}
#| title: "Available Editors"
show(available_editors)
```

```{python}

# Get a list of all editors over time that have supported pyOpenSci
ignore_editors = ["TBD"]
editors = [
    editor
    for editor in pd.unique(reviews.editor)
    if editor not in ignore_editors
]
n_edits = (
    reviews.groupby([reviews["editor"], reviews["Date Opened"].dt.to_period("Q")])
    .size()
    .reset_index(name="n_edits")  # Ensures a DataFrame with column name
)
```



```{python}

n_edits_filtered = n_edits[~n_edits["editor"].isin(ignore_editors)]
n_edits_filtered = n_edits_filtered.rename(columns={"Date Opened": "Date", "n_edits": "count"})
# Date should be a standard date time
df = n_edits_filtered.copy()
df[["Year", "Quarter"]] = df["Date"].astype(str).str.extract(r"(\d{4})Q(\d)").astype(int)
df["Date"] = pd.to_datetime(df["Year"].astype(str) + "-" + (3 * (df["Quarter"].astype(int) - 1) + 1).astype(str) + "-01")
```

```{python}
# This likely should be active edits?
edits = reviews.rename(columns={"Date Opened": "Date"}).copy()
```


```{python}

# Ensure datetime and a clean quarter label
# 2023 is when we started running again with funding
edits = reviews[["editor", "Name", "Date Opened"]]
edits = edits.rename(columns={"Date Opened": "Date", "Name":"package_name"})
edits = edits[edits["editor"] != "TBD"]
edits["Date"] = pd.to_datetime(edits["Date"])
edits["Year"] = edits["Date"].dt.year
edits = edits[edits["Year"] >= 2023]

```

## Editor Activity by Quarter 

## Row {height=auto}

```{python}
# Add quarter counts
edits["QuarterNum"] = edits["Date"].dt.quarter
edits["QuarterLabel"] = edits["Year"].astype(str) + " Q" + edits["QuarterNum"].astype(str)

quarter_order = sorted(edits["QuarterLabel"].unique())
edits["QuarterLabel"] = pd.Categorical(edits["QuarterLabel"], categories=quarter_order, ordered=True)

# Count edits per editor and quarter
df = (
    edits.groupby(["editor", "QuarterLabel"])
    .size()
    .reset_index(name="count")
)

all_editors = df["editor"].unique()
all_quarters = df["QuarterLabel"].cat.categories

full_index = pd.MultiIndex.from_product(
    [all_editors, all_quarters],
    names=["editor", "QuarterLabel"]
)
df_full = (
    df.set_index(["editor", "QuarterLabel"])
      .reindex(full_index, fill_value=0)
      .reset_index()
)

```

```{python}
quarter_order = sorted(df["QuarterLabel"].unique())
df["QuarterLabel"] = pd.Categorical(df["QuarterLabel"], categories=quarter_order, ordered=True)

facet_wrap = 2  
num_editors = len(df["editor"].unique())
num_rows = (num_editors + facet_wrap - 1) // facet_wrap
row_height = 300 

fig = px.bar(
    df,
    x="QuarterLabel",
    y="count",
    facet_col="editor",
    facet_row_spacing=0.04, 
    facet_col_spacing=0.06, 
    facet_col_wrap=facet_wrap,
    color_discrete_sequence=["indigo"],
    labels={"count": "Number of edits"},
    title="Review Count by Quarter (Since 2023)",
    height=row_height * num_rows,
    width=1200,
)

fig = fig.for_each_annotation(
    lambda a: a.update(text=a.text.split("=")[-1], font=dict(size=16))
)
fig = fig.update_xaxes(
    tickangle=45,
    tickfont=dict(size=10),
    showticklabels=True
)
fig = fig.update_yaxes(
    dtick=1,
    tickformat=",d",
    title_text="Review Count",
    range=[0, 4]
)
fig = fig.update_layout(
    xaxis_title="",
    showlegend=False,
    margin=dict(t=80),
    title_font_size=24,
)

fig.show()

```

## Row {height=auto}

## Summary 

This is the end of the dashboard.